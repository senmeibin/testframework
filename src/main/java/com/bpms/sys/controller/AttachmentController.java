package com.bpms.sys.controller;import com.google.common.collect.Maps;import com.bpms.core.consts.AppCodeConsts;import com.bpms.core.entity.AjaxResult;import com.bpms.core.entity.UploadResult;import com.bpms.core.utils.*;import com.bpms.sys.entity.ext.AttachmentExt;import com.bpms.sys.service.AttachmentAccessLogService;import com.bpms.sys.service.AttachmentService;import org.apache.commons.io.IOUtils;import org.apache.commons.lang3.StringUtils;import org.springframework.beans.factory.annotation.Autowired;import org.springframework.http.HttpStatus;import org.springframework.http.MediaType;import org.springframework.http.ResponseEntity;import org.springframework.stereotype.Controller;import org.springframework.ui.Model;import org.springframework.util.FileCopyUtils;import org.springframework.web.bind.annotation.RequestMapping;import org.springframework.web.bind.annotation.RequestMethod;import org.springframework.web.bind.annotation.RequestParam;import org.springframework.web.bind.annotation.ResponseBody;import org.springframework.web.multipart.MultipartFile;import org.springframework.web.multipart.MultipartHttpServletRequest;import javax.activation.MimetypesFileTypeMap;import javax.servlet.http.HttpServletRequest;import java.io.*;import java.util.HashMap;import java.util.Map;/** * 附件文件控制器类 */@Controller@RequestMapping("/sys/attachment")public class AttachmentController extends SysBaseController<AttachmentExt> {    /**     * Service对象     */    @Autowired    protected AttachmentService attachmentService;    @Autowired    private AttachmentAccessLogService attachmentAccessLogService;    /**     * 取得Service对象     */    @Override    public AttachmentService getService() {        return attachmentService;    }    /**     * 数据一览画面初期化     *     * @param model Model对象     * @return 数据一览JSP页面     * @throws IOException     * @throws IllegalAccessException     * @throws InstantiationException     */    @Override    @RequestMapping(value = {"list", ""}, method = RequestMethod.GET)    public String list(Model model) throws IllegalAccessException, IOException, InstantiationException {        return super.list(model);    }    /**     * 初始化下拉框选项内容     *     * @param model Model对象     * @throws IllegalAccessException     * @throws IOException     */    @Override    public void initOptionList(Model model) throws IllegalAccessException, IOException {        Map<String, Object> dicMap = new HashMap<>();        //应用名称        dicMap.put("appCode", this.getDropdownList("sys_application", "app_code", "app_name"));        model.addAttribute("jsonOptionList_" + this.getEntityName(), this.toJSON(dicMap, true));    }    /**     * 上传附件     *     * @param request HttpServletRequest     * @return Json字符串     * @throws Exception     */    @RequestMapping(value = "uploading", method = RequestMethod.POST)    @ResponseBody    public String uploading(HttpServletRequest request) throws Exception {        UploadResult uploadResult = new UploadResult();        MultipartHttpServletRequest multipartRequest = (MultipartHttpServletRequest) request;        //获取前台fileMap集合        Map<String, MultipartFile> fileMap = multipartRequest.getFileMap();        //系统中文件上传的根目录 取得        String uploadRootPath = this.parameterService.getValue(AppCodeConsts.APP_COMMON, "FILE_UPLOAD_PATH", request.getServletContext().getRealPath("/"));        //上传相对路径        String relationUploadPath = FileUtils.getUploadRelationPath(uploadRootPath);        //设置文件地址 = 设置的文件上传路径 + upload + 当前年月        String ctxPath = uploadRootPath + relationUploadPath;        //循环fileMap 取出file        for (Map.Entry<String, MultipartFile> entity : fileMap.entrySet()) {            //附件文件            MultipartFile mf = entity.getValue();            String fileName = mf.getOriginalFilename();            //构成新文件名（默认以UID 命名）            String newFileName = UniqueUtils.getUID();            //如果是有扩展名的文件，加上扩展名            if (fileName.lastIndexOf(".") >= 0) {                newFileName += fileName.substring(fileName.lastIndexOf("."));            }            //创建文件            File uploadFile = new File(ctxPath + newFileName);            try {                //copy文件到 创建的文件中                FileCopyUtils.copy(mf.getBytes(), uploadFile);                //保存文件的信息                AttachmentExt attachment = new AttachmentExt();                //应用编号                attachment.setAppCode(request.getParameter("appCode"));                //文件名                attachment.setFileName(fileName);                //文件地址(上传相对路径 + 文件名）--- 例 upload/201801/uid.xls                attachment.setFilePath(relationUploadPath + newFileName);                //文件大小                attachment.setFileSize(FileUtils.formatFileSize(uploadFile.length()));                //MIME类型                attachment.setMimeType(new MimetypesFileTypeMap().getContentType(fileName));                //关联UID                attachment.setRelationUid(request.getParameter("relationUid"));                //附件分类                attachment.setCategoryCd(request.getParameter("categoryCd"));                //模块名称                attachment.setModuleName(request.getParameter("moduleName"));                //判断文件是否为图像格式                if (ImageUtils.isImage(fileName)) {                    //获取标签传递值判断是否需要压缩图片 大图                    if (Integer.parseInt(request.getParameter("bigImageWidth") == null ? "0" : request.getParameter("bigImageWidth")) > 0 && Integer.parseInt(request.getParameter("bigImageHeight") == null ? "0" : request.getParameter("bigImageHeight")) > 0) {                        attachment.setBigImagePath(relationUploadPath + ImageUtils.compressImage(ctxPath, ctxPath, newFileName, 200, 200));                    }                    //获取标签传递值判断是否需要压缩图片 小图                    if (Integer.parseInt(request.getParameter("smallImageWidth") == null ? "0" : request.getParameter("smallImageWidth")) > 0 && Integer.parseInt(request.getParameter("smallImageHeight") == null ? "0" : request.getParameter("smallImageHeight")) > 0) {                        attachment.setSmallImagePath(relationUploadPath + ImageUtils.compressImage(ctxPath, ctxPath, newFileName, 200, 200));                    }                }                //可用状态                attachment.setRecordStatus(1);                //保存文件信息                attachmentService.save(attachment);            } catch (IOException e) {                uploadResult.setResult(-1);                if (log.isErrorEnabled()) {                    log.error("文件上传出错。", e);                }                uploadResult.setMessage(e.getMessage());            }        }        //Uploadify Firefox兼容，此处只能返回Json字符串，不能直接返回uploadResult对象        return JsonUtils.toJSON(uploadResult);    }    /**     * 附件文件下载     *     * @param uid 附件UID     * @return ResponseEntity     * @throws IOException     */    @RequestMapping(value = "download", method = RequestMethod.GET)    public ResponseEntity<byte[]> download(@RequestParam("uid") String uid) throws IOException {        //写入附件访问日志        AttachmentExt attachment = this.attachmentAccessLogService.writeAttachmentAccessLog(uid, 1);        //附件文件实体不存在的场合        if (attachment == null) {            this.getResponse().sendRedirect("/error/FileNotFound");            if (log.isInfoEnabled()) {                log.info("附件文体不存在。");            }            return null;        }        return this.downloadFile(attachment.getFileName(), attachment.getFilePath(), attachment.getMimeType());    }    /**     * 在线预览附件文件     *     * @param uid 附件UID     * @return ResponseEntity     * @throws Exception     */    @RequestMapping(value = "preview", method = RequestMethod.GET)    public ResponseEntity<byte[]> preview(@RequestParam("uid") String uid) throws Exception {        //写入附件访问日志        AttachmentExt attachment = this.attachmentAccessLogService.writeAttachmentAccessLog(uid, 0);        //附件文件实体不存在的场合        if (attachment == null) {            this.getResponse().sendRedirect("/error/FileNotFound");            if (log.isInfoEnabled()) {                log.info("附件文体不存在。");            }            return null;        }        try {            //文件名称            String fileName = this.convertDownloadFileName(attachment.getFileName());            //设置输出的格式            this.getResponse().reset();            this.getResponse().setContentType(attachment.getMimeType());            this.getResponse().setHeader("Content-Disposition", "inline; filename=\"" + fileName + "\"");            //系统中文件上传的根目录 取得            String uploadPath = this.parameterService.getValue(AppCodeConsts.APP_COMMON, "FILE_UPLOAD_PATH", this.getRequest().getServletContext().getRealPath("/"));            //创建文件流            InputStream inputStream = new FileInputStream(uploadPath + attachment.getFilePath());            OutputStream outputStream = this.getResponse().getOutputStream();            byte[] buffer = new byte[1024];            int len;            //输出流            while ((len = inputStream.read(buffer)) > 0) {                outputStream.write(buffer, 0, len);            }            //关闭流            IOUtils.closeQuietly(inputStream);            IOUtils.closeQuietly(outputStream);        } catch (IOException e) {            //报错  重定向FileNotFound页面            this.getResponse().sendRedirect("/error/FileNotFound");            if (log.isErrorEnabled()) {                log.error("文件预览出错，文件可能不存在。", e);            }            return null;        }        return new ResponseEntity<>(HttpStatus.OK);    }    /**     * 上传图片     *     * @param request HttpServletRequest     * @return AjaxResult     */    @ResponseBody    @RequestMapping(value = "uploadImages", method = RequestMethod.POST)    public String uploadImages(HttpServletRequest request) throws Exception {        UploadResult uploadResult = new UploadResult();        //大压缩图相对路径        String bigPictureUrl = StringUtils.EMPTY;        //小压缩图相对路径        String smallPictureUrl = StringUtils.EMPTY;        //大图宽        String bigWidth = request.getParameter("bigImageWidth");        //大图高        String bigHeight = request.getParameter("bigImageHeight");        //小图宽        String smallWidth = request.getParameter("smallImageWidth");        //小图高        String smallHeight = request.getParameter("smallImageHeight");        //moduleName        String moduleName = request.getParameter("moduleName");        MultipartHttpServletRequest multipartRequest = (MultipartHttpServletRequest) request;        //获取前台fileMap集合        Map<String, MultipartFile> fileMap = multipartRequest.getFileMap();        //系统中文件上传的根目录 取得        String uploadRootPath = this.parameterService.getValue(AppCodeConsts.APP_COMMON, "FILE_UPLOAD_PATH", request.getServletContext().getRealPath("/"));        log.info("系统中文件上传的根目录：" + uploadRootPath);        //图片相对路径        String uploadPath = FileUtils.getUploadRelationPath(uploadRootPath);        //设置文件地址        String ctxPath = uploadRootPath + uploadPath;        log.info("图片存储路径：" + ctxPath);        //循环fileMap 取出file        for (Map.Entry<String, MultipartFile> entity : fileMap.entrySet()) {            //附件文件            MultipartFile mf = entity.getValue();            String fileName = mf.getOriginalFilename();            //构成新文件名            String newFileName = UniqueUtils.getUID() + fileName.substring(fileName.lastIndexOf("."));            //原图片存储的相对路径            String pictureUrl = uploadPath + newFileName;            //创建文件            File uploadFile = new File(ctxPath + newFileName);            try {                //copy文件到 创建的文件中                FileCopyUtils.copy(mf.getBytes(), uploadFile);                //判断文件是否为图像格式                if (!"-1".equals(bigWidth) && !"-1".equals(bigHeight)) {                    //压缩图片 并返回路径                    bigPictureUrl = uploadPath + ImageUtils.compressImage(ctxPath, ctxPath, newFileName, Integer.parseInt(bigWidth), Integer.parseInt(bigHeight));                }                if (!"-1".equals(smallWidth) && !"-1".equals(smallHeight)) {                    smallPictureUrl = uploadPath + ImageUtils.compressImage(ctxPath, ctxPath, newFileName, Integer.parseInt(smallWidth), Integer.parseInt(smallHeight));                }                uploadResult.setMessage("图像文件上传成功。");                uploadResult.setPictureUrl(pictureUrl);                uploadResult.setBigPictureUrl(bigPictureUrl);                uploadResult.setSmallPictureUrl(smallPictureUrl);                uploadResult.setFileSize(FileUtils.formatFileSize(uploadFile.length()));                uploadResult.setMimeType(new MimetypesFileTypeMap().getContentType(fileName));                uploadResult.setModuleName(moduleName);                uploadResult.setFileName(fileName);            } catch (Exception ex) {                uploadResult.setResult(-1);                uploadResult.setMessage(ex.getMessage());            }        }        //Uploadify Firefox兼容，此处只能返回Json字符串，不能直接返回uploadResult对象        return JsonUtils.toJSON(uploadResult);    }    /**     * 旋转图片     *     * @param degree     旋转角度     * @param sourcePath 源图片路径     * @return AjaxResult对象     */    @ResponseBody    @RequestMapping(value = "rotateImage", method = RequestMethod.POST, produces = MediaType.APPLICATION_JSON_VALUE)    public AjaxResult rotateImage(HttpServletRequest request, int degree, String sourcePath) throws Exception {        AjaxResult ajaxResult = new AjaxResult();        //系统中文件上传的根目录 取得        String uploadRootPath = this.parameterService.getValue(AppCodeConsts.APP_COMMON, "FILE_UPLOAD_PATH", request.getServletContext().getRealPath("/"));        //源图片路径带域名场合        if (sourcePath.contains("http://")) {            String domain = sourcePath.substring(0, sourcePath.indexOf("/upload"));            sourcePath = sourcePath.substring(sourcePath.indexOf("/upload"), sourcePath.length());            String url = domain + "/sys/attachment/rotateImage";            //远程调用旋转图片接口进行图片旋转            Map<String, Object> paramsMap = Maps.newHashMap();            //旋转角度            paramsMap.put("degree", degree);            //源图片路径            paramsMap.put("sourcePath", sourcePath);            //返回的结果            String resultJson = HttpUtils.doPost(url, paramsMap);            ajaxResult = JsonUtils.parseJSON(resultJson, AjaxResult.class);        }        else {            //本地图片直接旋转            String fullSourcePath = uploadRootPath + sourcePath;            ImageUtils.rotate(degree, fullSourcePath, fullSourcePath);        }        return ajaxResult;    }}